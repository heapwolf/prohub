var db = require('../../db');
var stoa = require('stream-to-array');
var xtend = require('xtend');
var moment = require('moment');
var ASSERT = require('assert').ok;
var ObjectId = require('node-time-uuid');
var levelUpdater = require('level-updater');
var client = require('gh/client');

var template = {
  name: '',
  projects: []
};

var qopts = { headers: { 'user-agent': 'Node' } };

exports.getProject = function(token, name, stream, cb) {
  db.sublevel('projects').get(name, function(err, data) {

    var repocount = data.repos.length;
    var count = 0;
    var agg = {
      name: data.name,
      repos: {}
    };

    if (!repocount) return cb(null, agg);

    var loadTotal  = repocount;
    var loadComplete = 0;

    return data.repos.map(function(repo) {

      var url = repo.split('/');
      var opts = { repo: url.pop(), user: url.pop(), token: token };

      client.getRepo(opts, function(err, r) {

        client.getIssues(xtend(opts, { state: 'all' }), function(err, i) {

          stream.write({ 
            page: 'project', 
            loading: { 
              url: repo + '/issues', 
              percentage: ((++loadComplete / 100) * loadTotal) * 100
            }
          });

          if (err) return cb(err);

          client.getMilestones(opts, function(err, m) {
            if (err) return cb(err);

            stream.write({ 
              page: 'project',  
              loading: { 
                url: repo + '/milestones', 
                percentage: ((++loadComplete / 100) * loadTotal) * 100
              } 
            });

            client.getContributors(opts, function(err, c) {
              if (err) return cb(err);

              stream.write({ 
                page: 'project', 
                loading: { 
                  url: repo + '/contributors', 
                  percentage: ((++loadComplete / 100) * loadTotal) * 100
                } 
              });

              agg.repos[repo] = {
                issues: i,
                milestones: m,
                contributors: c,
                description: r.description
              };

              if (++count == repocount) cb(null, agg);
            });
          });
        });
      });
    });

  });
};

exports.addProject = function(name, cb) {
  var id = new ObjectId();
  var key = id.toString('hex');

  var project = {
    name: name,
    id: key,
    createdAt: (new Date()).toISOString(),
    repos: []
  };

  db.sublevel('projects').put(key, project, function(err) {
    if (err) return cb(err);
    project.id = key;
    return cb(null, project);
  });
};

exports.listProjects = function(cb) {
  stoa(db.sublevel('projects').createReadStream(), function(err, arr) {
    if (err) return cb(err);

    var result = {}; 
    arr = arr.reverse();
    for (var i = 0; i < arr.length; ++i) {
      var id = arr[i].key;
      result[id] = arr[i].value;
    }
    return cb(null, result);
  });
};


/* var projectUpdates = {
  addRepo: levelUpdater(db.sublevel('projects'), 
    function(value, param, key) {
    if (!Array.isArray(value.repos)) {
      value.repos = [];
    }

    value.repos.push(String(param));
    return value;
  }),
  removeRepo: levelUpdater(db.sublevel('projects'), 
    function(value, param, key) {
    if (!Array.isArray(value.repos)) {
      return value;
    }

    value.repos.push(String(param));
    return value;
  }),
  rename: levelUpdater(db.sublevel('projects'), 
    function(value, param, key) {
    value.name = param;
    return value;
  })
};*/

/**
 * Check if string is valid object id
 *
 * @param {string} string UUID string
 * @returns {bool}
 */
function isValidUUID(string) {
  try {
    var result = new ObjectId(string);
    return true;
  } catch (e) {
    return false;
  }
}

exports.deleteProject = function(opts, cb) {
  var key = opts.projectId;

  if (!key || !isValidUUID(key)) {
    return cb(new Error('projectId required'));
  }

  db.sublevel('projects').del(key, cb);
}

exports.renameProject = function(opts, cb) {
  var key = opts.projectId;
  var name = opts.name;

  if (!key || !isValidUUID(key)) {
    return cb(new Error('projectId required'));
  }

  if (!name || 'string' !== typeof name) {
    return cb(new Error('projectId required'));
  }

  var name = name.trim();
  if ('' === name) {
    return cb(new Error('empty project name'));
  }

  projectUpdates.rename(key, name, cb);
};

exports.addRepository = function(opts, cb) {
  db.sublevel('projects').get(opts.projectId, function(err, val) {
    if (err) return cb(err);
    val.repos.push(opts.url);
    db.sublevel('projects').put(opts.projectId, val, cb);
  });
};

exports.removeRepository = function(opts, cb) {
  db.sublevel('projects').get(opts.projectId, function(err, val) {
    if(err) return cb(err);
    //val.repos.push(opts.repoURL);
    //db.put(opts.projectId, cb);
  });
};

function tokenAsString(token) {
  return JSON.stringify(token);
}

/**
 * Verified GitHub tokens
 */
var verifiedTokens = db.sublevel('verifiedTokens');

/**
 * Lookup token in verified tokens sublevel
 */
exports.getVerifiedToken = function(opts, cb) {
  ASSERT(opts.token);
  var tokenString = tokenAsString(opts.token);
  verifiedTokens.get(tokenString, function(err, v) {
    if (err) return cb(err);
    var timeDiff = (Date.now() - v) / 1000;
    if (timeDiff > 60 * 60 * 24 /* 24 hours */) {
      return cb(new Error('token expired'));
    }

    return cb(null, true);
  });
};

/**
 * Save token into verified tokens sublevel
 */
exports.putVerifiedToken = function(opts, cb) {
  ASSERT(opts.token);
  var tokenString = tokenAsString(opts.token);
  verifiedTokens.put(tokenString, Date.now(), cb);
};

